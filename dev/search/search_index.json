{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"DFT/DFT/","title":"About K-points","text":"<p>When you solve the Schr\u00f6dinger equation for a periodic system like a crystal, the solution can be broken into two parts: one that describes how the wavefunction behaves within each unit cell, and another that describes how it changes across unit cells. The k-points tell you how the wavefunction shifts as you move from one cell to the next. At the Gamma point (k = 0), there\u2019s no change, the wavefunction looks identical in every cell. As you move to small k, the wavefunction shifts gradually across the crystal, which allows you to describe a more complex wavefunction than one in which the same thing just repeats in each unit cell. At the edges of the Brillouin zone, the wavefunction can \u201cflip\u201d from one unit cell to the next, like alternating sign. So, when describing all the solutions to the Schr\u00f6dinger equation, k-points basically allow you to separate it into parts that can be more intuitive to interpret(and calculate). </p>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/","title":"Installation CASTEP - AOCL","text":""},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#castep-2512-aocl-ubuntu-2404-ryzen-3900x-guia-final","title":"CASTEP 25.12 + AOCL (Ubuntu 24.04, Ryzen 3900X) \u2014 Guia Final","text":""},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#0-pre-requisitos","title":"0) Pr\u00e9-requisitos","text":"<pre><code>sudo apt update\nsudo apt install -y build-essential gfortran cmake git \\\n    libopenmpi-dev openmpi-bin \\\n    libfftw3-dev python3 python3-pip gawk\n</code></pre> <p>Confirme MPI</p> <pre><code>which mpif90\nwhich mpirun\n# Esperado:\n# /usr/bin/mpif90\n# /usr/bin/mpirun\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#1-definir-aocl-e-diretorios-de-biblioteca","title":"1) Definir AOCL e diret\u00f3rios de biblioteca","text":"<p>Voc\u00ea instalou o AOCL em: /opt/AMD/aocl/aocl-linux-gcc-5.1.0</p> <p>Defina vari\u00e1veis e caminho das libs (LP64):</p> <pre><code>export AOCL=/opt/AMD/aocl/aocl-linux-gcc-5.1.0\nexport LIBDIR=$AOCL/gcc/lib_LP64\nexport LD_LIBRARY_PATH=$LIBDIR:$LD_LIBRARY_PATH\n\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#2-ajustar-symlinks-das-libs-aocl-uma-vez-so","title":"2) Ajustar symlinks das libs AOCL (uma vez s\u00f3)","text":"<p>O CASTEP procura libblis.so e libflame.so. No AOCL encontramos:</p> <pre><code>/opt/AMD/aocl/aocl-linux-gcc-5.1.0/gcc/lib_LP64/libblis.so.5.1.0\n/opt/AMD/aocl/aocl-linux-gcc-5.1.0/gcc/lib_LP64/libflame.so\n</code></pre> <p>Crie os symlinks (no mesmo diret\u00f3rio):</p> <pre><code>cd /opt/AMD/aocl/aocl-linux-gcc-5.1.0/gcc/lib_LP64\nsudo ln -s libblis.so.5.1.0 libblis.so\nsudo ln -s libblis-mt.so.5.1.0 libblis-mt.so\n# libflame.so j\u00e1 tem o nome esperado\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#3-descompactar-o-castep","title":"3) Descompactar o CASTEP","text":"<pre><code>tar -zxf CASTEP-25.12.tar.gz\ncd CASTEP-25.12\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#4-compilar-serial-e-mpi-com-aocl-fftw3","title":"4) Compilar (serial e MPI) com AOCL + FFTW3","text":"<p>4.1 Serial (opcional, \u00fatil para utilit\u00e1rios)</p> <pre><code>make clean\nmake -j$(nproc) COMMS_ARCH=serial \\\n     MATHLIBS=aocl MATHLIBDIR=\"$LIBDIR\" \\\n     FFT=fftw3  FFTLIBDIR=\"$LIBDIR\" \\\n     BUILD=fast TARGETCPU=host\nmake COMMS_ARCH=serial install\n</code></pre> <p>Instala em:</p> <pre><code>bin/linux_x86_64_gfortran10--serial/\n</code></pre> <p>4.2 MPI (principal)</p> <pre><code>make clean\nmake -j$(nproc) COMMS_ARCH=mpi \\\n     MATHLIBS=aocl MATHLIBDIR=\"$LIBDIR\" \\\n     FFT=fftw3  FFTLIBDIR=\"$LIBDIR\" \\\n     BUILD=fast TARGETCPU=host\nmake COMMS_ARCH=mpi install\n\n</code></pre> <p>Instala em:</p> <pre><code>bin/linux_x86_64_gfortran10--mpi/\n\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#5-verificar-linkedicao-com-aocl","title":"5) Verificar linkedi\u00e7\u00e3o com AOCL","text":"<pre><code>ldd obj/linux_x86_64_gfortran*/castep.mpi | grep -E \"blis|flame\"\n# Esperado (caminhos AOCL):\n# libflame.so =&gt; /opt/AMD/aocl/aocl-linux-gcc-5.1.0/gcc/lib_LP64/libflame.so\n# libblis.so.5 =&gt; /opt/AMD/aocl/aocl-linux-gcc-5.1.0/gcc/lib_LP64/libblis.so.5\n# libblis-mt.so.5 =&gt; /opt/AMD/aocl/aocl-linux-gcc-5.1.0/gcc/lib_LP64/libblis-mt.so.5\n\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#6-teste-rapido-mpi","title":"6) Teste r\u00e1pido (MPI)","text":"<p>Com arquivos si.cell/si.param prontos, rode:</p> <pre><code>mpirun -np 4 ~/CASTEP/CASTEP-25.12/bin/linux_x86_64_gfortran10--mpi/castep.mpi si\n</code></pre> <p>(Ajuste -np conforme desejar.)</p>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#7-persistir-ambiente-no-bashrc","title":"7) Persistir ambiente no ~/.bashrc","text":"<p>Abra o arquivo:</p> <pre><code>nano ~/.bashrc\n</code></pre> <p>Adicione ao final (usando os mesmos nomes de vari\u00e1veis/comandos que usamos acima):</p> <pre><code># === AOCL libraries ===\nexport AOCL=/opt/AMD/aocl/aocl-linux-gcc-5.1.0\nexport LD_LIBRARY_PATH=$AOCL/gcc/lib_LP64:$LD_LIBRARY_PATH\n\n# === CASTEP binaries (MPI) ===\nexport PATH=$HOME/CASTEP/CASTEP-25.12/bin/linux_x86_64_gfortran10--mpi:$PATH\n</code></pre> <p>Salve e recarregue:</p> <pre><code>source ~/.bashrc\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#8-wrapper-para-simplificar-mpirun-np-castepmpi","title":"8) Wrapper para simplificar mpirun -np ... castep.mpi","text":"<p>Crie /usr/local/bin/castep-mpi:</p> <pre><code>sudo bash -lc 'cat &gt; /usr/local/bin/castep-mpi &lt;&lt; \"EOF\"\n#!/bin/bash\n# Uso: castep-mpi &lt;nprocs&gt; &lt;seed&gt; [args...]\nNPROCS=\"$1\"\nSEED=\"$2\"\nshift 2\nmpirun -np \"$NPROCS\" $HOME/CASTEP/CASTEP-25.12/bin/linux_x86_64_gfortran10--mpi/castep.mpi \"$SEED\" \"$@\"\nEOF\nchmod +x /usr/local/bin/castep-mpi'\n</code></pre> <p>Agora voc\u00ea pode rodar assim:</p> <pre><code>castep-mpi 4 si\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#9-duvidas-comuns-troubleshooting","title":"9) D\u00favidas comuns / Troubleshooting","text":"<p>MPI_ABORT ... errorcode 1 logo no in\u00edcio Quase sempre \u00e9 falta de pseudopotencial. Use OTFG no .cell:</p> <pre><code>%BLOCK SPECIES_POT\nSi  OTFG  [Si] 3|2.0|2.0|2.0:2|6.0|8.0|10.0\n%ENDBLOCK SPECIES_POT\n</code></pre> <p>ou defina PSPOT_DIR para .usp.</p> <p>cannot find -lflame / -lblis Garanta:</p> <pre><code>export LIBDIR=$AOCL/gcc/lib_LP64\n\nexport LD_LIBRARY_PATH=$LIBDIR:$LD_LIBRARY_PATH\n</code></pre> <p>symlinks criados (passo 2).</p> <p>Utilit\u00e1rios reclamando diret\u00f3rio --serial ausente no make install \u00c9 normal se voc\u00ea instalou s\u00f3 MPI. Para instalar utilit\u00e1rios, tamb\u00e9m rode o build/instala\u00e7\u00e3o serial:</p> <pre><code>make COMMS_ARCH=serial BUILD=fast TARGETCPU=host\nmake COMMS_ARCH=serial install\n</code></pre> <p>Quantos processos usar? Sua CPU tem 12 cores f\u00edsicos / 24 threads. Comece testando:</p> <p>castep-mpi 12 si (1 MPI por core f\u00edsico)</p> <p>compare com castep-mpi 24 si (1 MPI por thread)</p> <p>e com castep-mpi 4 si (teste leve)</p>"},{"location":"DFT/Installation%20CASTEP%20-%20AOCL/#10-exemplo-final-de-execucao","title":"10) Exemplo final de execu\u00e7\u00e3o","text":"<pre><code># com wrapper e 12 processos (recomenda\u00e7\u00e3o inicial)\ncastep-mpi 12 si\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/","title":"Installation CASTEP - MKL","text":""},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#castep-2512-intel-mkl-openmpi-on-ubuntu-2404","title":"CASTEP 25.12 + Intel MKL + OpenMPI on Ubuntu 24.04","text":"<p>This guide explains how to install and run CASTEP 25.12 with Intel MKL and OpenMPI on Ubuntu 24.04.</p>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#system-information","title":"System Information","text":"<ul> <li>CPU: <code>Intel Core i9</code> (24 cores / 32 threads)</li> <li>RAM: <code>128 GB</code></li> <li>OS: <code>Ubuntu 24.04 LTS</code></li> <li>Compilers: <code>GNU Fortran 13.x</code></li> <li>MPI: <code>OpenMPI 4.1.x</code></li> <li>Math library: <code>Intel MKL</code> (installed via <code>apt</code>)</li> </ul>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#prerequisites","title":"Prerequisites","text":"<p>Install required packages:</p> <pre><code>sudo apt update\nsudo apt install -y build-essential gfortran cmake git \\\n    libopenmpi-dev openmpi-bin \\\n    libfftw3-dev python3 python3-pip gawk intel-mkl\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#locating-mkl-libraries","title":"Locating MKL Libraries","text":"<p>MKL libraries are installed in <code>/lib/x86_64-linux-gnu/</code> and headers in <code>/usr/include/mkl</code>.</p> <p>Check:</p> <pre><code>ldconfig -p | grep mkl\nls /usr/include/mkl\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#environment-setup","title":"Environment Setup","text":"<p>Add to your <code>~/.bashrc</code>:</p> <pre><code># === Intel MKL ===\nexport MKL_LIB=/lib/x86_64-linux-gnu\nexport MKL_INC=/usr/include/mkl\nexport INCLUDE=$MKL_INC\nexport LD_LIBRARY_PATH=$MKL_LIB:$LD_LIBRARY_PATH\n\n# Avoid MPI + MKL thread oversubscription\nexport MKL_INTERFACE_LAYER=LP64\nexport MKL_THREADING_LAYER=GNU\nexport OMP_NUM_THREADS=1\n\n# === CASTEP binaries ===\nexport PATH=$HOME/CASTEP/CASTEP-25.12/bin/linux_x86_64_gfortran10--mpi:$PATH\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#building-castep","title":"Building CASTEP","text":"<p>Unpack the source:</p> <pre><code>tar -zxf CASTEP-25.12.tar.gz\ncd CASTEP-25.12\n</code></pre> <p>Clean previous build </p> <pre><code>rm -rf obj/linux_x86_64_gfortran10--mpi\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#mpi-build-with-mkl","title":"MPI build with MKL","text":"<p>First run make</p> <p>!!! warning \"DL_MG=None\"     In this setup, we were not able install dl_mg module. We have tried several times and the following error kept being thrown out during make statement.Error:     <code>/usr/bin/ld: /home/numsim/CASTEP/CASTEP-25.12/obj/linux_x86_64_gfortran10--mpi/build/../../../Source/Functional/multigrid_dlmg.f90:444:(.text+0x146db): undefined reference to __dl_mg_MOD_dl_mg_error_string' collect2: error: ld returned 1 exit status make[1]: *** [Makefile:220: ../castep.mpi] Error 1 rm f90wrap_stub.anc make[1]: Leaving directory '/home/numsim/CASTEP/CASTEP-25.12/obj/linux_x86_64_gfortran10--mpi/build' make: *** [make.inc:236: castep] Error 2</code> As a solution we have chosen the following command:</p> <pre><code>make -j$(nproc) COMMS_ARCH=mpi DL_MG=none \\\n  MATHLIBS=mkl MATHLIBDIR=\"$MKL_LIB\" \\\n  FFT=mkl FFTLIBDIR=\"$MKL_LIB\" \\\n  EXTRA_LIBS=\"-Wl,--start-group -lmkl_intel_lp64 -lmkl_gnu_thread -lmkl_core -Wl,--end-group -lsymspg -lgomp -lpthread -lm -ldl\" \\\n  LDFLAGS=\"-L$MKL_LIB -Wl,--no-as-needed -Wl,-rpath,$MKL_LIB\" \\\n  BUILD=fast TARGETCPU=host\n</code></pre> <p>then install:</p> <pre><code>make COMMS_ARCH=mpi install\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#verifying-installation","title":"Verifying installation","text":"<p>Check that the binary links against MKL and spglib:</p> <pre><code>ldd bin/linux_x86_64_gfortran10--mpi/castep.mpi | grep -E \"mkl|symspg\"\n</code></pre> <p>Run version header check:</p> <pre><code>mpirun -np 4 bin/linux_x86_64_gfortran10--mpi/castep.mpi --version\n</code></pre> <p>Expected: MKL and OpenMPI are listed.</p>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#wrapper-script","title":"Wrapper Script","text":"<p>To run only commadn castep-mpi as default</p> <pre><code>sudo bash -lc 'cat &gt; /usr/local/bin/castep-mpi &lt;&lt; \"EOF\"\n#!/bin/bash\n# Usage: castep-mpi &lt;nprocs&gt; &lt;seed&gt; [args...]\nNPROCS=\"$1\"; SEED=\"$2\"; shift 2\nmpirun -np \"$NPROCS\" --bind-to core \"$HOME/CASTEP/CASTEP-25.12/bin/linux_x86_64_gfortran10--mpi/castep.mpi\" \"$SEED\" \"$@\"\nEOF\nchmod +x /usr/local/bin/castep-mpi'\n</code></pre> <p>Now you run jobs with:</p> <pre><code>castep-mpi 24 si\n</code></pre>"},{"location":"DFT/Installation%20CASTEP%20-%20MKL/#troubleshoting","title":"Troubleshoting","text":"<p>MPI_ABORT error at start: missing pseudopotential \u2192 check SPECIES_POT block or PSPOT_DIR.</p> <p>Falls back to generic BLAS (-llapack -lblas): ensure MKL paths are set and passed to make.</p> <p>Undefined DL_MG symbols: either disable (DL_MG=none) or build DL_MG (DL_MG=compile) if available in your source</p>"},{"location":"DFT/Python%20Runner/","title":"CASTEP Runner","text":"<p>You find our python package to run automated scans in castep using the wraper castep-mpi on ubuntu plataforms. here</p>"},{"location":"DFT/Python%20Runner/#castep-runner-user-guide","title":"CASTEP Runner \u2014 User Guide","text":""},{"location":"DFT/Python%20Runner/#introduction","title":"Introduction","text":"<p><code>CASTEP Runner</code> is a modular Python wrapper that automates launching <code>castep-mpi</code> calculations. It helps organize runs in dedicated folders, automatically edits CASTEP input files, and supports parameter scans.</p> <p>Highlights:</p> <ul> <li>Edits <code>cut_off_energy</code> in <code>.param</code> files.</li> <li>Edits <code>kpoint_mp_grid</code> in <code>.cell</code> files.</li> <li>Stages all relevant input files into a clean run directory.</li> <li>Executes <code>castep-mpi &lt;np&gt; &lt;seedname&gt;</code> inside that directory.</li> <li>Supports single runs and scans (cutoff or k-grid).</li> <li>Provides <code>--dry-run</code> mode for setup without execution.</li> </ul>"},{"location":"DFT/Python%20Runner/#installation","title":"Installation","text":"<p>Requirements:</p> <ul> <li>Python 3.8+</li> <li><code>castep-mpi</code> in your <code>$PATH</code></li> </ul> <p>Clone or copy the package structure:</p> <pre><code>project/\n\u251c\u2500 run_castep.py\n\u2514\u2500 castep_runner/\n   \u251c\u2500 __init__.py\n   \u251c\u2500 cli.py\n   \u251c\u2500 io_utils.py\n   \u251c\u2500 param_edit.py\n   \u251c\u2500 cell_edit.py\n   \u251c\u2500 runner.py\n   \u2514\u2500 constants.py\n</code></pre> <p>Make the entry point executable:</p> <pre><code>chmod +x run_castep.py\n</code></pre>"},{"location":"DFT/Python%20Runner/#usage","title":"Usage","text":""},{"location":"DFT/Python%20Runner/#single-cutoff-run","title":"Single cutoff run","text":"<pre><code>python run_castep.py &lt;NP&gt; &lt;SEEDNAME&gt; --cutoff &lt;INT&gt;\n</code></pre> <ul> <li>Creates <code>cutoffs/&lt;seedname&gt;_&lt;cutoff&gt;/</code></li> <li>Stages inputs</li> <li>Ensures <code>cut_off_energy : &lt;cutoff&gt; eV</code> in <code>.param</code></li> <li>Runs CAStep</li> </ul>"},{"location":"DFT/Python%20Runner/#cutoff-scan","title":"Cutoff scan","text":"<pre><code>python run_castep.py &lt;NP&gt; &lt;SEEDNAME&gt; --cutoff-scan START END STEP\n</code></pre> <ul> <li>Generates subdirectories for each cutoff value.</li> <li>Inclusion rule: always include <code>START</code>; include <code>END</code> only if reached exactly by stepping.</li> </ul>"},{"location":"DFT/Python%20Runner/#single-k-point-grid","title":"Single k-point grid","text":"<pre><code>python run_castep.py &lt;NP&gt; &lt;SEEDNAME&gt; --kgrid NX NY NZ\n</code></pre> <ul> <li>Creates <code>kgrids/&lt;seedname&gt;_&lt;NX&gt;x&lt;NY&gt;x&lt;NZ&gt;/</code></li> <li>Edits <code>.cell</code> with <code>kpoint_mp_grid NX NY NZ</code></li> <li>Runs CAStep</li> </ul>"},{"location":"DFT/Python%20Runner/#k-grid-scan","title":"K-grid scan","text":"<pre><code>python run_castep.py &lt;NP&gt; &lt;SEEDNAME&gt; --kgrid-scan S1 E1 T1  S2 E2 T2  S3 E3 T3\n</code></pre> <ul> <li>First triple <code>(S1,E1,T1)</code>: starting grid.</li> <li>Second triple <code>(S2,E2,T2)</code>: ending grid.</li> <li>Third triple <code>(S3,E3,T3)</code>: step increments.</li> <li>All three axes advance together. Non-varying axes should have step <code>0</code>.</li> </ul> <p>Examples:</p> <ul> <li>Vary only Nx:</li> </ul> <p><code>bash   python run_castep.py 4 SiO2 --kgrid-scan 2 2 2  6 2 2  2 0 0   # \u2192 (2 2 2), (4 2 2), (6 2 2)</code> * Vary all axes equally:</p> <p><code>bash   python run_castep.py 4 SiO2 --kgrid-scan 2 2 2  8 8 8  2 2 2   # \u2192 (2 2 2), (4 4 4), (6 6 6), (8 8 8)</code></p> <p>Inclusion rule: start is always included; end is included only if exactly reached.</p>"},{"location":"DFT/Python%20Runner/#dry-run","title":"Dry run","text":"<pre><code>python run_castep.py 4 SiO2 --cutoff 700 --dry-run\n</code></pre> <p>Prepares the directory and edits inputs but does not execute CAStep.</p>"},{"location":"DFT/Python%20Runner/#input-staging","title":"Input Staging","text":"<ul> <li>Copies <code>.cell</code>, <code>.param</code>, <code>.usp</code>, and other relevant files.</li> <li>Copies any <code>seedname.*</code> file as a catch-all.</li> <li>Existing files in run directories are not overwritten.</li> </ul>"},{"location":"DFT/Python%20Runner/#editing-behavior","title":"Editing Behavior","text":"<ul> <li>.param: ensures a line <code>cut_off_energy : &lt;value&gt; eV</code> exists and updates it.</li> <li>.cell: ensures a line <code>kpoint_mp_grid &lt;nx&gt; &lt;ny&gt; &lt;nz&gt;</code> exists and updates it.</li> </ul>"},{"location":"DFT/Python%20Runner/#output-organization","title":"Output Organization","text":"<ul> <li>Cutoff runs: <code>cutoffs/&lt;seedname&gt;_&lt;cutoff&gt;/</code></li> <li>K-grid runs: <code>kgrids/&lt;seedname&gt;_&lt;nx&gt;x&lt;ny&gt;x&lt;nz&gt;/</code></li> </ul> <p>Each folder contains both inputs and outputs, ensuring reproducibility.</p>"},{"location":"DFT/Python%20Runner/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> \u2014 success</li> <li><code>127</code> \u2014 <code>castep-mpi</code> not found</li> <li><code>1</code> \u2014 missing required input file (<code>.param</code> or <code>.cell</code>)</li> <li><code>2</code> \u2014 invalid scan arguments</li> <li>Non-zero from CAStep \u2014 propagated upwards</li> </ul>"},{"location":"DFT/Python%20Runner/#extending","title":"Extending","text":"<ul> <li>Parallel scans: add <code>--jobs N</code> and use multiprocessing.</li> <li>Additional parameters: implement in <code>param_edit.py</code> or <code>cell_edit.py</code>.</li> <li>Scheduler integration: replace direct run with SLURM/LSF submission.</li> </ul>"},{"location":"DFT/Python%20Runner/#programmatic-api","title":"Programmatic API","text":"<pre><code>from castep_runner.io_utils import ensure_run_dir, stage_inputs\nfrom castep_runner.param_edit import set_cutoff_in_param\nfrom castep_runner.cell_edit import set_kgrid_in_cell\nfrom castep_runner.runner import run_castep\n\nrun_dir = ensure_run_dir(\"SiO2\", 700)\nstage_inputs(\"SiO2\", run_dir)\nset_cutoff_in_param(run_dir/\"SiO2.param\", 700)\nset_kgrid_in_cell(run_dir/\"SiO2.cell\", 4, 4, 4)\nrc = run_castep(4, \"SiO2\", run_dir)\n</code></pre>"},{"location":"DFT/Python%20Runner/#maintainer-notes","title":"Maintainer Notes","text":"<ul> <li>Keep CLI logic in <code>cli.py</code>.</li> <li>Keep editing isolated in <code>param_edit.py</code> and <code>cell_edit.py</code>.</li> <li>Add tests around scan behavior (cutoff and k-grid) to ensure reproducibility.</li> </ul>"},{"location":"NMR%20Lectures/lecture_1/","title":"Lecture 1 \u2013 Basics of NMR: Classical and Quantum Pictures","text":"<p>\u201cIt's the job that's never started as takes longest to finish.\u201d J.R.R. Tolkien (Lord of the Rings)</p> <p>These notes introduce two complementary ways of thinking about NMR:</p> <ol> <li>A classical vector model, in which we follow a macroscopic magnetization vector \\( M \\) in a magnetic field.</li> <li>And a quantum model, in which we describe individual nuclear spins with wavefunctions and operators.</li> </ol> <p>Both pictures describe two different physics that results into measuring macroscopically the same quantity, ie., magnetic signal from a sample.</p>"},{"location":"NMR%20Lectures/lecture_1/#1-classical-vector-model-of-nmr","title":"1. Classical Vector Model of NMR","text":""},{"location":"NMR%20Lectures/lecture_1/#11-net-magnetization-from-many-spins","title":"1.1 Net Magnetization from Many Spins","text":"<p>Real NMR signals come from many nuclei \u2013 typically on the order of Avogadro\u2019s number. Each nucleus carries a magnetic moment vector \\( \\mu_i \\). Summing them over the whole sample gives the net magnetization which can be written as:</p> \\[ M = \\sum_{i} \\mu_i \\] <ul> <li>In zero magnetic field, the individual moments are randomly oriented, ie, their vector sum is (on average) zero.</li> <li>In a static magnetic field \\( B_0 \\), more spins align along the field direction than against it, ie, a small but nonzero net magnetization \\( M \\) appears.</li> </ul> <p>Placeholder for figure: [Fig. 1: Random spin orientations with \\(B_0 = 0\\) vs. slight alignment when \\(B_0 \\neq 0\\).]</p> <p>Later, we\u2019ll connect this classical \\( M \\) to underlying quantum populations. But let us not get ahead of ourselves.</p>"},{"location":"NMR%20Lectures/lecture_1/#12-torque-on-magnetization-in-a-static-field","title":"1.2 Torque on Magnetization in a Static Field","text":"<p>Classically, a magnetic moment \\( \\mu \\) in a field \\( B \\) experiences a torque</p> \\[ \\tau = \\mu \\times B \\] <p>For the whole sample, we treat the macroscopic magnetization \\( M \\) as playing the role of a single big magnetic moment. Then</p> \\[ \\tau = M \\times B \\] <p>On the other hand, torque is also related to the rate of change of angular momentum \\( J \\):</p> \\[ \\tau = \\frac{dJ}{dt} \\] <p>For nuclear spins, the magnetic moment and angular momentum are proportional:</p> \\[ \\mu = \\gamma I \\] <p>for a single spin, where</p> <ul> <li>\\( I \\) = nuclear spin angular momentum,</li> <li>\\( \\gamma \\) = magnetogyric ratio (a constant characteristic of each nucleus, e.g. \\(^1\\)H, \\(^{13}\\)C).</li> </ul> <p>Extending this to the ensemble we have</p> \\[ M = \\gamma J \\] <p>So</p> \\[ \\tau  = \\frac{dJ}{dt}  = \\frac{1}{\\gamma} \\frac{dM}{dt} \\] <p>Equating this with the torque from the magnetic field:</p> \\[ \\frac{1}{\\gamma}\\frac{dM}{dt} = M \\times B \\] <p>or</p> \\[ \\boxed{ \\frac{dM}{dt} = \\gamma\\, M \\times B } \\] <p>This is the equation of motion for the magnetization vector.</p>"},{"location":"NMR%20Lectures/lecture_1/#13-larmor-precession","title":"1.3 Larmor Precession","text":"<p>Now we have to specialize to a static, uniform magnetic field along the \\(z\\)-axis which is typically the case we face in the experiments:</p> \\[ B_0 = (0, 0, B_0) \\] <p>Insert this into the equation of motion we have derived</p> \\[ \\frac{dM}{dt} = \\gamma\\, M \\times B_0 \\] <p>Write \\( M = (M_x, M_y, M_z) \\). Then the cross product gives:</p> \\[ M \\times B_0  =  \\begin{pmatrix} M_x \\\\ M_y \\\\ M_z \\end{pmatrix} \\times \\begin{pmatrix} 0 \\\\ 0 \\\\ B_0 \\end{pmatrix} = \\begin{pmatrix} M_y B_0 \\\\ - M_x B_0 \\\\ 0 \\end{pmatrix} \\] <p>So</p> \\[ \\frac{dM_x}{dt} = \\gamma\\, M_y B_0 \\] \\[ \\frac{dM_y}{dt} = -\\gamma\\, M_x B_0 \\] \\[ \\frac{dM_z}{dt} = 0 \\] <p>Key points:</p> <ul> <li>\\(M_z\\) is constant in time.</li> <li>\\(M_x\\) and \\(M_y\\) rotate in the \\(xy\\)-plane.</li> </ul> <p>We can combine these into a single complex variable</p> \\[ M_\\perp = M_x + i M_y \\] <p>Then</p> \\[ \\frac{dM_\\perp}{dt}  = \\frac{d}{dt}(M_x + iM_y) = \\gamma B_0 M_y + i(-\\gamma B_0 M_x) = -i \\gamma B_0 (M_x + iM_y) = -i \\gamma B_0 M_\\perp \\] <p>This differential equation has solution</p> \\[ M_\\perp(t) = M_\\perp(0)\\, e^{-i \\omega_0 t} \\] <p>where</p> \\[ \\boxed{ \\omega_0 = \\gamma B_0 } \\] <p>is the Larmor frequency.</p> <p>Geometrically, this means that \\( M \\) precesses around \\( B_0 \\) at angular frequency \\( \\omega_0 \\).</p> <p>Placeholder for figure: [Fig. 2: Magnetization vector precessing around the \\(z\\)-axis at \\(\\omega_0\\).]</p>"},{"location":"NMR%20Lectures/lecture_1/#14-adding-an-rf-field-pulsed-nmr-and-the-rotating-frame","title":"1.4 Adding an RF Field: Pulsed NMR and the Rotating Frame","text":"<p>In a pulsed NMR experiment, we apply an additional radiofrequency (rf) field using a coil. This field is typically:</p> <ul> <li>oscillating at frequency \\( \\omega_{\\text{rf}} \\),</li> <li>perpendicular to \\(B_0\\),</li> <li>of magnitude \\(B_1\\) (much smaller than \\(B_0\\)).</li> </ul> <p>A convenient idealization:</p> \\[ B_1(t) = (B_1 \\cos \\omega_{\\text{rf}} t,\\; B_1 \\sin \\omega_{\\text{rf}} t,\\; 0) \\] <p>The total field is then:</p> \\[ B(t) = B_0 + B_1(t) \\] <p>Solving the exact motion in the lab frame is possible but messy. Instead, NMR uses the rotating frame.</p>"},{"location":"NMR%20Lectures/lecture_1/#141-the-rotating-frame-idea","title":"1.4.1 The Rotating Frame Idea","text":"<p>Imagine looking at the system from a coordinate frame rotating around the \\(z\\)-axis at angular frequency \\( \\omega_{\\text{rf}} \\). In this frame:</p> <ul> <li>The oscillating \\( B_1(t) \\) can become approximately static if we choose the rotation properly.</li> <li>The large static field \\(B_0\\) is partly transformed away.</li> </ul> <p>Mathematically, in the rotating frame the magnetization obeys:</p> \\[ \\frac{dM}{dt}\\Big|_{\\text{rot}} =  \\gamma\\, M \\times B_{\\text{eff}} \\] <p>where the effective field is</p> \\[ B_{\\text{eff}} = \\left( B_1,\\; 0,\\; \\frac{\\omega_0 - \\omega_{\\text{rf}}}{\\gamma} \\right) \\] <p>(Here we\u2019ve chosen \\(B_1\\) along the rotating-frame \\(x\\)-axis for simplicity.)</p> <p>Special case: on-resonance pulse</p> <ul> <li>If \\( \\omega_{\\text{rf}} = \\omega_0 \\) then   \\(\\frac{\\omega_0 - \\omega_{\\text{rf}}}{\\gamma} = 0\\) so  \\(B_{\\text{eff}} = (B_1, 0, 0)\\)</li> <li>The magnetization precesses purely around the \\(x\\)-axis at angular frequency \\( \\omega_1 = \\gamma B_1 \\).</li> </ul>"},{"location":"NMR%20Lectures/lecture_1/#142-flip-angle-and-pulse-duration","title":"1.4.2 Flip Angle and Pulse Duration","text":"<p>In the rotating frame, if \\( M \\) starts along the \\(+z\\)-axis and the rf field \\( B_1 \\) is applied along \\(+x\\), \\( M \\) simply rotates around the \\(x\\)-axis.</p> <p>The nutation frequency (rate of rotation about \\(B_1\\)) is:</p> \\[ \\omega_1 = \\gamma B_1 \\] <p>If the pulse is applied for a duration \\(t_{\\text{rf}}\\), the flip angle (rotation angle) is:</p> \\[ \\boxed{ \\theta_{\\text{rf}} = \\omega_1 t_{\\text{rf}} = \\gamma B_1 t_{\\text{rf}} } \\] <p>Important special cases:</p> <ul> <li>\\(90^\\circ\\) pulse (or \\(\\pi/2\\) pulse):</li> </ul> \\[   \\theta_{\\text{rf}} = \\frac{\\pi}{2} \\quad \\Rightarrow \\quad t_{\\pi/2} = \\frac{\\pi}{2 \\gamma B_1} \\] <p>Rotates \\(M\\) from \\(+z\\) into the transverse plane (e.g. along \\(-y\\) if pulse is along \\(+x\\)).</p> <ul> <li>\\(180^\\circ\\) pulse (or \\(\\pi\\) pulse):</li> </ul> \\[   \\theta_{\\text{rf}} = \\pi \\quad \\Rightarrow \\quad t_{\\pi} = \\frac{\\pi}{\\gamma B_1} \\] <p>Inverts \\(M\\) from \\(+z\\) to \\(-z\\).</p> <p>Placeholder for figure: [Fig. 3: Effect of a \\(90^\\circ_x\\) pulse: magnetization initially along \\(z\\) tipped into \\(-y\\) direction in rotating frame.]</p> <p>After the pulse, if we stop the rf field, then \\( B_{\\text{eff}} \\) reduces back to just the effective static field, and in the rotating frame the magnetization either:</p> <ul> <li>remains fixed (if on resonance), or</li> <li>precesses about \\(z\\) at \\( \\omega_0 - \\omega_{\\text{rf}} \\) (if off resonance).</li> </ul>"},{"location":"NMR%20Lectures/lecture_1/#2-quantum-model-of-nmr","title":"2. Quantum Model of NMR","text":"<p>The classical description works well for intuition and for systems of many uncoupled spins. But to describe interactions (dipolar couplings, quadrupolar effects, etc.) and to derive everything from first principles, we need the quantum mechanical model.</p>"},{"location":"NMR%20Lectures/lecture_1/#21-single-spin-wavefunctions-and-operators","title":"2.1 Single Spin, Wavefunctions, and Operators","text":"<p>Quantum mechanically, a single spin is described by a state vector (wavefunction) \\( |\\psi\\rangle \\), and physical quantities are represented by operators.</p> <p>For one spin:</p> <ul> <li>The spin angular momentum operator is \\( \\hat{I} = (\\hat{I}_x, \\hat{I}_y, \\hat{I}_z) \\).</li> <li>The magnitude squared is \\( \\hat{I}^2 \\).</li> </ul> <p>For a spin with quantum number \\( I \\):</p> <ul> <li>\\( \\hat{I}^2 |I, m\\rangle = \\hbar^2 I(I+1) |I, m\\rangle \\)</li> <li>\\( \\hat{I}_z |I, m\\rangle = \\hbar m |I, m\\rangle \\)</li> </ul> <p>with</p> <ul> <li>\\( I = 0, \\frac{1}{2}, 1, \\frac{3}{2}, \\dots \\)</li> <li>\\( m = I, I-1, \\dots, -I \\)</li> </ul> <p>For NMR, the most common case is spin-\u00bd:</p> <ul> <li>\\( I = \\frac{1}{2} \\)</li> <li>\\( m = +\\frac{1}{2} \\) (often called \\( |\\alpha\\rangle \\)) or \\( m = -\\frac{1}{2} \\) (often called \\( |\\beta\\rangle \\)).</li> </ul>"},{"location":"NMR%20Lectures/lecture_1/#22-zeeman-hamiltonian-spin-in-a-static-magnetic-field","title":"2.2 Zeeman Hamiltonian: Spin in a Static Magnetic Field","text":"<p>A magnetic moment operator \\( \\hat{\\mu} \\) is proportional to the spin operator:</p> \\[ \\hat{\\mu} = \\gamma \\hbar \\hat{I} \\] <p>Place the spin in a static magnetic field \\( B_0 = (0, 0, B_0) \\). The energy (Hamiltonian operator) is</p> \\[ \\hat{H} = - \\hat{\\mu} \\cdot B_0        = - \\gamma \\hbar \\hat{I} \\cdot (0,0,B_0)        = - \\gamma \\hbar B_0 \\hat{I}_z \\] <p>We now find the energy eigenstates by applying \\( \\hat{H} \\) to \\( |I, m\\rangle \\):</p> \\[ \\hat{H} |I, m\\rangle = - \\gamma \\hbar B_0 \\hat{I}_z |I, m\\rangle                      = - \\gamma \\hbar B_0 (\\hbar m) |I, m\\rangle                      = E_{I,m} |I, m\\rangle \\] <p>Thus</p> \\[ \\boxed{ E_{I,m} = - \\gamma \\hbar^2 B_0\\, m } \\] <p>Often the factor of \\( \\hbar \\) is absorbed into the definition of \\( \\hat{I}_z \\), so one writes simply</p> \\[ E_{I,m} = - \\gamma \\hbar B_0 m \\] <p>For a spin-\u00bd:</p> <ul> <li>\\( m = +\\frac{1}{2} \\): \\( E_{+} = - \\frac{1}{2} \\gamma \\hbar B_0 \\)</li> <li>\\( m = -\\frac{1}{2} \\): \\( E_{-} = + \\frac{1}{2} \\gamma \\hbar B_0 \\)</li> </ul> <p>The energy splitting between the two levels is</p> \\[ \\Delta E = E_{-} - E_{+} = \\gamma \\hbar B_0 \\] <p>Dividing by \\( \\hbar \\), we get a frequency:</p> \\[ \\frac{\\Delta E}{\\hbar} = \\gamma B_0 = \\omega_0 \\] <p>This is exactly the Larmor frequency we found in the classical picture.</p> <p>Important connection: Classical precession frequency of \\( M \\) = quantum transition frequency between Zeeman levels.</p>"},{"location":"NMR%20Lectures/lecture_1/#23-thermal-populations-and-ensemble-magnetization","title":"2.3 Thermal Populations and Ensemble Magnetization","text":"<p>Real samples contain many spins. At nonzero temperature, spins occupy the energy levels with Boltzmann probabilities.</p> <p>For a level with energy \\( E_y \\), the equilibrium population fraction is</p> \\[ p_y = \\frac{e^{-E_y / k_B T}}{\\sum_{y'} e^{-E_{y'} / k_B T}} \\] <p>For a spin-\u00bd in a field \\( B_0 \\):</p> <ul> <li>Upper level \\( |\\beta\\rangle \\) (higher energy): \\( E_{-} \\)</li> <li>Lower level \\( |\\alpha\\rangle \\) (lower energy): \\( E_{+} \\)</li> </ul> <p>Since \\( \\Delta E = \\gamma \\hbar B_0 \\) is typically much smaller than \\( k_B T \\), we can approximate populations, but for now we keep the exact expression.</p> <p>The z-component of the magnetic moment operator is</p> \\[ \\hat{\\mu}_z = \\gamma \\hbar \\hat{I}_z \\] <p>The ensemble-averaged magnetization along \\(z\\) is</p> \\[ \\langle M_z \\rangle = N \\langle \\hat{\\mu}_z \\rangle \\] <p>where \\(N\\) = number of spins, and</p> \\[ \\langle \\hat{\\mu}_z \\rangle  = \\sum_y p_y \\langle y | \\hat{\\mu}_z | y \\rangle \\] <p>For spin-\u00bd, there are only two states: \\( |\\alpha\\rangle \\) and \\( |\\beta\\rangle \\).</p> <ul> <li>\\( \\hat{I}_z |\\alpha\\rangle = +\\frac{\\hbar}{2} |\\alpha\\rangle \\)</li> <li>\\( \\hat{I}_z |\\beta\\rangle = -\\frac{\\hbar}{2} |\\beta\\rangle \\)</li> </ul> <p>Therefore</p> \\[ \\langle \\hat{\\mu}_z \\rangle  = p_\\alpha \\gamma \\hbar \\left(+\\frac{1}{2}\\right) + p_\\beta \\gamma \\hbar \\left(-\\frac{1}{2}\\right) = \\gamma \\hbar \\frac{1}{2}(p_\\alpha - p_\\beta) \\] <p>so the macroscopic magnetization is</p> \\[ \\boxed{ \\langle M_z \\rangle = N \\gamma \\hbar \\frac{1}{2} (p_\\alpha - p_\\beta) } \\] <p>Thus:</p> <ul> <li>The nonzero net magnetization comes from the slight excess of spins in the lower energy state.</li> <li>This quantum population difference is what the classical vector \\( M \\) really represents.</li> </ul>"},{"location":"NMR%20Lectures/lecture_1/#24-classical-vs-quantum-summary","title":"2.4 Classical vs Quantum: Summary","text":"<ul> <li>Classical picture</li> <li>Describes the time evolution of a macroscopic magnetization vector \\( M \\).</li> <li>Magnetization precesses around \\( B_0 \\) at \\( \\omega_0 = \\gamma B_0 \\).</li> <li> <p>RF pulses rotate \\( M \\) by an angle \\( \\theta_{\\text{rf}} = \\gamma B_1 t_{\\text{rf}} \\) in the rotating frame.</p> </li> <li> <p>Quantum picture</p> </li> <li>Describes each nuclear spin with states \\( |I,m\\rangle \\) and a Hamiltonian \\( \\hat{H} = - \\gamma \\hbar B_0 \\hat{I}_z \\).</li> <li>Energy levels are split by \\( \\Delta E = \\gamma \\hbar B_0 \\).</li> <li>Net magnetization arises from slight Boltzmann imbalance between populations.</li> </ul> <p>They are two ways of telling the same story:</p> <ul> <li>Classical: a precessing arrow in space.</li> <li>Quantum: two (or more) energy levels with populations and transitions.</li> </ul> <p>Both are essential to solid-state NMR: - We often think in the classical picture, - But we calculate complicated experiments in the quantum (density operator) language.</p> <p>End of Lecture 1.</p>"},{"location":"SIMPSON/Installation/","title":"Installation","text":""},{"location":"SIMPSON/Installation/#overview","title":"Overview","text":"<p>This document describes how to install SIMPSON 4.2.1 on Ubuntu, and how to fix a common Tcl version mismatch error.</p> <p>The process was tested successfully on:</p> <ul> <li> <p>Ubuntu 24.04 + AMD processor (with optimized BLAS/LAPACK/FFTW for AMD)</p> </li> <li> <p>Ubuntu 24.04 + Intel i9 processor (with optimized BLAS/LAPACK/FFTW for Intel)</p> </li> </ul> <p>Both setups also included MPI (mpirun) for parallel execution.</p>"},{"location":"SIMPSON/Installation/#1-installation","title":"1. Installation","text":"<p>After downloading SIMPSON 4.2.1, run the installer script:</p> <pre><code>sudo ./install.sh\n</code></pre> <p>This installs the simpson wrapper into /usr/local/bin and the libraries into /usr/share/simpson</p> <p>If you try</p> <pre><code>simpson test.in\n</code></pre> <p>you going to face the following error:</p> <pre><code>SIMPSON is unable to initialize Tcl interpreter. Is init.tcl on your path? Error: Can't find a usable init.tcl in the following directories: /usr/share/simpson/tcl8.6 /usr/share/tcltk/tcl8.6 ./lib/tcl8.6 ./lib/tcl8.6 ./library ./library ./tcl8.6.5/library ./tcl8.6.5/library /usr/share/tcltk/tcl8.6/init.tcl: version conflict for package \"Tcl\": have 8.6.5, need exactly 8.6.14 version conflict for package \"Tcl\": have 8.6.5, need exactly 8.6.14 while executing \"package require -exact Tcl 8.6.14\" (file \"/usr/share/tcltk/tcl8.6/init.tcl\" line 19) invoked from within \"source /usr/share/tcltk/tcl8.6/init.tcl\" (\"uplevel\" body line 1) invoked from within \"uplevel #0 [list source $tclfile]\"\n</code></pre> <p>The cause is SIMPSON installer ships with an outdated Tcl 8.6.5 but the SIMPSON 4.2.1 binary is built against Tcl 8.6.14. This mismath prevents startups.</p>"},{"location":"SIMPSON/Installation/#fixing-the-tcl-issue","title":"Fixing the tcl issue","text":"<p>Instead of using the bundled Tcl, we point SIMPSON to Ubuntu\u2019s system Tcl (already at 8.6.14). Edit the following wrapper script:</p> <pre><code>sudo nano /usr/local/bin/simpson\n</code></pre> <p>Change only these two lines:</p> <pre><code>export TCL_LIBRARY=/usr/share/simpson/tcl8.6\nexport LD_LIBRARY_PATH=/usr/share/simpson\n</code></pre> <p>to </p> <pre><code>export TCL_LIBRARY=/usr/share/tcltk/tcl8.6\nexport LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu\n</code></pre> <p>save and exit.</p>"},{"location":"SIMPSON/Installation/#verification","title":"Verification","text":"<p>Run now the same command:</p> <pre><code>simpson test.in\n</code></pre>"},{"location":"SIMPSON/Installation/#parallel-execution","title":"Parallel execution","text":"<p>If you have installed the packages for parallel execution (you can refer the DFT documentation in this website to install them). You can run</p> <pre><code>mpirun -np 8 simpson test.in\n</code></pre> <p>The flag <code>np</code> is used to account for the number of total processor. If you have a 4 machines with 2 cores, then your np should be 4x2, which is 8 in the example above.</p>"},{"location":"SIMPSON/Installation/#notes-on-hardware","title":"Notes on Hardware","text":"<ul> <li> <p>On AMD-based Ubuntu, SIMPSON runs correctly with AMD-optimized math libraries (BLAS/LAPACK/FFTW).</p> </li> <li> <p>On Intel i9-based Ubuntu, SIMPSON also runs correctly with Intel-optimized libraries.</p> </li> </ul> <p>Both environments had MPI (mpirun) installed for distributed simulations, and no MPI-related issues occurred.</p>"},{"location":"SIMPSON/SIMPSON/","title":"SIMPSON Overview","text":""},{"location":"SIMPSON/SIMPSON/#what-is-simpson","title":"What is SIMPSON?","text":"<p>SIMPSON (Simulation Program for Solid-State NMR) is a powerful open-source program for simulating nuclear magnetic resonance (NMR) experiments, especially in the solid state.</p> <p>It was originally developed by Thomas Vosegaard and collaborators, and is widely used in research groups worldwide for designing, analyzing, and understanding complex NMR experiments.</p> <p>At its core, SIMPSON allows users to:</p> <ul> <li> <p>Define spin systems and Hamiltonians</p> </li> <li> <p>Simulate pulse sequences (1D, 2D, MAS, multi-pulse)</p> </li> <li> <p>Include powder averaging and relaxation models</p> </li> <li> <p>Compare simulated spectra with experimental results</p> </li> </ul>"},{"location":"SIMPSON/SIMPSON/#why-use-simpson","title":"Why Use SIMPSON?","text":"<ul> <li> <p>Flexibility: Supports a broad range of NMR experiments (solid-state and liquid-state).</p> </li> <li> <p>Accuracy: Handles both simple and highly complex spin systems.</p> </li> <li> <p>Extendability: Uses Tcl scripting for defining simulations, making it customizable.</p> </li> <li> <p>Performance: Supports MPI (via mpirun) and optimized math libraries (BLAS/LAPACK/FFTW).</p> </li> </ul> <p>SIMPSON is particularly useful when:</p> <p>Designing new experiments before performing them on the spectrometer.</p> <p>Understanding the effects of anisotropic interactions (CSA, dipolar, quadrupolar).</p> <p>Benchmarking experimental data against theoretical predictions.</p> <p>In this page, you also will find how to install SIMPSON program in your linux environment.</p>"},{"location":"SIMPSON/SIMPSON/#how-to-run-simpson","title":"How to run simpson","text":"<p>Simpson can be invoked via terminal:</p> <pre><code>simpson &lt;filename&gt;\n</code></pre> <p>It is also possible to run it in parallel with the following command:</p> <pre><code>mpirun -np &lt;n&gt; &lt;filename&gt;\n</code></pre>"},{"location":"SIMPSON/SIMPSON/#how-to-write-a-simpson-file","title":"How to write a simpson file","text":"<p>You can find how to write an input file for simpson using this link</p>"}]}